# 객체 지향 프로그래밍

객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 **객체**들의 **모임**으로 파악하고자 하는 것이다. 각각의 **객체**는 **메시지**를 주고받고, 데이터를 처리할 수 있다. **(협력)**

객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

&nbsp;

### 다형성

스프링은 다형성이 가장 중요하며, 다형성을 극대화해서 이용할 수 있게 도와준다.

**다형성이란?** 어떤 객체의 속성이나 기능이 상황에 따라 **여러 가지 형태를 가질 수** 있는 성질이다.

- 클래스

클래스에서 다형성 예시로 첫 번째는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있다.

두 번째는 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있다.

- 메서드

메서드에서의 다형성은 메서드 **오버라이딩**과 메서드 **오버로딩**이 있다.

&nbsp;
### 역할과 구현을 분리

다형성을 이용하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.

다형성을 통해 역할과 구현을 분리하면

- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 **내부 구조를 몰라도** 된다.
- 클라이언트는 구현 대상의 **내부 구조가 변경되어도** 영향을 받지 않는다.
- 클라이언트는 구현 **대상 자체를 변경해도** 영향을 받지 않는다.

&nbsp;

자바 언어에서의 다형성의 활용은 아래와 같다.

- 역할 = 인터페이스

```java
public interface MemberRepository {
    void save(Member member);

    Member findBy(Long memberId);
}
```

- 구현=인터페이스를 구현한 클래스, 구현 객체

```java
public class MemoryMemberRepository implements MemberRepository {

    private static Map<Long, Member> store = new HashMap<>();

    @Override
    public void save(Member member) {
        store.put(member.getId(), member);
    }

    @Override
    public Member findBy(Long memberId) {
        return store.get(memberId);
    }
}
```

스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

&nbsp;

# SOLID 원칙
클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리하였다.

1. SRP: 단일 책임 원칙
2. OCP: 개방-폐쇄 원칙
3. LSP: 리스코프 치환 원칙
4. ISP: 인터페이스 분리 원칙
5. DIP: 의존관계 역전 원칙

&nbsp;

### SRP

한 클래스는 **하나의 책임만** 가져야 한다.

변경이 있을 때, 파급 효과가 적도록 설계하는 것이다.

### OCP

소프트웨어 요소는 **확장에는 열려** 있으나 **변경에는 닫혀** 있어야 한다.

인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현한다. (역할과 구현 분리) 

그런데, 다형성을 만족한 설계라도 역할의 변경이 있으면 결국은 코드의 변경은 불가피 할텐데..?

→ 그래서 객체를 생성하고, 연관관계를 맺어주는 별도의 설정자가 필요하다.

### LSP

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

약속된 설계 속에서 구현체의 임의 기능 변경은 클린코드에 위반된다.

### ISP

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

인터페이스가 명확해지고, 대체 가능성이 높아진다.

### DIP

프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”

즉, 구현 클래스에 의존하지 말고, 인터페이스(역할)에 의존하라는 뜻이다.

클라이언트가 구현체 내부에서 무슨 일이 일어나는지 알 필요가 없다. 역할의 변경에만 유연하면 된다.

그런데, 기본적으로 객체 생성은 구현체를 의존하고 있을 뿐더러 OCP와 마찬가지로 역할을 변경하려면 결국 코드의 변경은 불가피하다.

&nbsp;

**결국 다형성 만으로 OCP, DIP를 지킬 수 없다.**

스프링의 등장으로 **다형성, OCP, DIP를 가능하게 지원**함으로써 클라이언트 코드의 변경 없이 기능을 확장할 수 있게 되었다.

