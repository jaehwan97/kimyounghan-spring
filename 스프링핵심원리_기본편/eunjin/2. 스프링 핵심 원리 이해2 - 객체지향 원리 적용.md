# 스프링 핵심 원리 이해 2
## 객체 지향 원리 적용

### [기획 변경] 새로운 할인 정책 추가

- 할인 정책이라는 ‘역할’ 인터페이스를 생성해둠
    
    그 아래에 현재는 Fix 할인 구현을 해뒀다면, 새로운 기획에 맞게 Rate할인 구현을 하면 됨 
    
- TEST 생성 단축키
    
    윈도우 : ctrl + shift + T
    
    테스트 생성 시에는 실패 테스트도 꼭 만들어 볼 것!
    

### 변경된 기획 적용

- 문제점
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/9ff247f1-462b-4ee2-bf5a-612082eb8f80/c9642d46-1d7f-4c19-a69b-089224f29e95/Untitled.png)
    
     order에서 변경해야 함 → OCP 위반 
    
    (예 - 차를 바꿨을때 면허증을 업데이트 해야하는 상황인 것)
    
    - 원인
        
        실제 코드를 보면 클라이언트가 역할인 인터페이스 뿐만 아니라 구현에도 의존하고 있음 
        
        → DIP 위반
        
- 해결법
    
    인터페이스 (역할)에만 의존하도록 코드를 변경해야 함 
    
    final을 없애면 됨
    
    → 새로운 문제점 : null pointer exception 발생
    
- 새로운 해결책
    
    문제를 해결하려면 누군가가 클라이언트인 OrderServiceImpl 에 DiscountPolicy 의 구현 객체를 대신 생성하고 주입해주어야 한다
    

### (중요) 관심사의 분리

- 지금까지의 구현을 비유하자면..
    
    배우가 본인의 역할과 상대 배우를 직접 초빙하는 것과 마찬가지임
    
    그러나 배우는 상대 배우가 누가 오던지 똑같이 공연을 할 수 있어야함
    
    즉, 배우와 기획자의 역할과 책임을 확실히 분리해야 함
    
- `**AppConfig**`
    
    애플리케이션의 전체 동작 방식을 구성(config)하기 위해서 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 클래스!! 
    
    즉, 연극에서의 **기획자**와 같은 역할을 함 
    
    - 구현
        
        MemberService를 불러다가 사용함 
        
        서비스를 불러서 사용할때, 그때 메모리를 불러줌
        
        → 기존의 MemberService에서 직접 메모리 선언하던 코드는 이제 없음!!! 외부에서 불러서 생성하는 코드만 있는 정말이지 빈껍데기!
        
        → 생성자 주입 (생성자 단축키 쓰기!!!)
        
    - 결론
        
        객체의 생성과 연결을 담당함
        
        연극으로 따지면 AppConfig가 상대 배우를 고르는 것
        

### AppConfig 리펙토링

- 리팩토링 단축키 - 메소드 추출 리팩토링
    
    Ctrl + Alt + M
    
    - 설명
        
        코드 중복을 방지하고 코드 가독성을 향상시키기 위해 사용됩니다. 선택한 코드 블록을 새로운 메소드로 추출하여 해당 코드를 여러 곳에서 재사용하거나 코드를 더 간결하게 만들 수 있습니다
        
    - 역할과 구현을 라인을 나눠서 작성하기

### 새로운 구조 + 할인 정책 적용

- AppConfig의 도입
    
    사용 영역과 구성 영역이 구분이 됨
    
    변경을 위해서는 구성 영역, 즉 AppConfig 의 코드만 간단하게 바꾸면 됨
    

### 좋은 객체 지향 설계의 5가지 원칙 적용

1. SRP 단일 책임 원칙 
    - 정의
        
        한 클래스는 하나의 책임만 가짐 
        
    - 적용
        
        클라이언트는 실행하는 역할만 담당하고, AppConfig가 구현 객체 생성하고 연결하는 역할 담당 
        
2. DIP 의존관계 역전 원칙 
    - 정의
        
        추상화에 의존해야지, 구체화에 의존하면 안된다
        
    - 적용
        
        AppConfig에서 구체화를 넣어주고, 나머지 코드는 추상화에 의존하게 됨
        
3. OCP 
    - 정의
        
        SW 요소는 확장에는 열려있지만 코드 변경에는 닫혀있어야 함 
        
    - 적용
        
        다형성 사용하고 클라이언트가 DIP를 지킴 
        
        그래서 AppConfig만 수정하면 되고 클라이언트 코드는 변경하지 않아도 됨
        

### IoC, DI, 컨테이너

- IoC (제어의 역전)
    
    프레임워크 같은거가 내 코드를 대신 실행해주는 것
    
    AppConfig를 통해서 구현 객체는 자신의 로직을 실행하는 역할만 담당하고, 프로그램 제어의 흐름은 AppConfig가 담당한다. 
    
    → 프로그램의 흐름 (어떤 객체가 호출되서 사용될지..) 를 AppConfig만 알 수 있음 
    
    - 프레임워크 vs 라이브러리
        
        프레임워크 - 내가 작성한 코드를 제어하고, 대신 실행하는 것 
        
        라이브러리 - 내가 작성한 코드가 직접 제어의 흐름을 담당함 
        
    - 의존관계 주입
        
        의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 를 분리해서 생각해야함
        
        - 정의
            
            애플리케이션 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결되는 것을 의미!!!!
            
        - 구현
            
            객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결 (생성자 사용)
            
        - 장점
            
            **정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경**할 수 있음 
            
- IoC 컨테이너, DI 컨테이너
    
    AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것
    

### 스프링으로 전환하기

- 스프링 설정 정보
    
    @ + 용어
    
- 전환 순서
    1. AppConfig에 스프링 설정 정보 추가 
    2. MemberApp에 applicatrionContext 추가
        
        `ApplicationContext applicationContext = new AnnotationConfigApplicationContext(``AppConfig.class);`
        
        추가
        
        의미 : 스프링이 AppConfig에 있는 것들을 넣어서 찾아준다. 
        
    3. MemberApp에 getBean 추가 
        
        `applicationContext.getBean("memberService", MemberSerivce.class);`
        
        AppConfig에서 꺼내오고 싶은 메서드 이름으로 이름 지어줘야 함 
        
- 정리
    - ApplicationContext = 스프링 컨테이너
    - 스프링 컨테이너를 사용해서 기존에 개발자가 AppConfig를 통해 직접 객체 생성하고 DI했던걸 얘가 대신 해줌
    - 골뱅이가 붙은 AppConfig를 설정 정보로 활용함
    - AppConfig에 골뱅이 Bean이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록함 → 이렇게 스프링 컨테이너에 등록한 객체가 바로 스프링 빈!!!
    - 스프링 빈은 applicationContext.getBean 메서드를 통해서 찾을 수 있음. 저거로 찾아서 사용해야함
- 장점?
    
    코드가 살짝 더 복잡해짐에도 스프링을 사용하는 장점이 무엇일까?