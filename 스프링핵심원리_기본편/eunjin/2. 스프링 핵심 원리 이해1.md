# 스프링 핵심 원리 이해 1
### 기본 세팅
Build Tools에서 Gradle → IntelliJ로 변경하기 

### 기본 설계
- 구현보다는 역할을 먼저 만들어야 함 → 회원 저장소, 회원 서비스, 클라이언트
    역할 == 인터페이스 
    
- 설계 순서
    1. 도메인 협력 관계 그림
    2. 클래스 다이어그램
    3. 객체 다이어그램 
        
        (클래스 다이어그램과의 차이점? - 실제 사용하는 메모리 같은건 동적이라 클래스 다이어그램만으로 판단이 어렵기 때문)
        

### 개발

- member 엔티티 생성
    - 생성자 윈도우 단축키 - alt + insert
- 저장소
    - 인터페이스 (역할) 생성
    - 구현체 생성
        
        멤버를 저장하고 찾는 함수 실제로 구현
        
- 서비스
    - 인터페이스 (역할) 생성
    - 구현체 생성
        
        회원을 찾기 위해서는 회원 저장소가 필요함
        
        null이 되면 안되기 때문에 **구현체로 객체**를 생성해줘야함
        

### 테스트

- Application 로직 테스트 → 좋은 방법이 아님
    - 테스트를 위한 MemberApp 클래스 생성
    - main 단축키 - `psvm + enter`
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/9ff247f1-462b-4ee2-bf5a-612082eb8f80/c81c3fdb-22ac-4e0a-98d1-340e9651f2a5/Untitled.png)
        
- JUnit 테스트
    - 검증
        Assertions.assertThat(객체 이름).isEqualTo(비교할 객체)
        (Assertions org.assertj.core.api)
        

### 생각

- 다른 저장소로 변경할 때 OCP 원칙을 잘 지키고 있는가?
- DIP를 잘 지키고 있는가?
    Service에서 Memory 구현체를 가져와서 객체로 사용해서 구현에 의존한 문제가 있음
    

---

### 주문, 할인 도메인 설계

- 역할과 구현을 분리해서 설계함
    → 자유롭게 구현 객체 분리 가능해짐
    
- 클래스 다이어그램
- 객체 다이어그램 (동적)
    회원을 조회하는 방식 (메모리 or 실제 DB) 나 정률 할인 정책이 변경되어도 주문 서비스를 변경하지 않아도 됨 (왜?)